---
calendar_date: 2023-04-11
catalog: true
categories:
- Linux
cover:
  image: /cover/cover2.jpeg
date: 2023-04-11 22:57:40
description: Linux 三剑客之RegExp
lang: cn
mathjax: false
tags:
- Bash
thumbnail: /img/header_img/lml_bg2.jpg
title: Grep、Sed、Awk 00 RegExp
toc: true
---

> “awk、grep、sed 是 linux 操作文本的三大利器，合称文本三剑客，也是必须掌握的 linux 命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属 awk 功能最强大，但也最复杂。grep 更适合单纯的查找或匹配文本，sed 更适合编辑匹配到的文本，awk 更适合格式化文本，对文本进行较复杂格式处理。“

[Linux文本三剑客超详细教程---grep、sed、awk](https://www.cnblogs.com/along21/p/10366886.html)

在介绍这三个命令之前，需要对正则表达式有所了解，结合正则表达式来使用，才能发挥这 linux 三剑客的的全部能力。

## 正则表达式 RegExp

正则表达式： Regual Expression 为一类特殊字符和文本符号共通约定的一种 pattern，其中的一些字符并不表示其本身的含义，而是用来做通配符号。

其中基本正则表达式 BRE 是普遍支持的，而拓展正则表达式 ERE 通常则是需要特殊的参数来启用的。通过正则表达式中特殊符号的辅助，能够更快的过滤，查找，替换，处理字符流等。

除了在 grep、sed、awk 的 linux 三剑客中，在各个语言和各种搜索函数的地方，正则表达式都被普遍支持，应用相当广泛。

基础正则表达式对应的元字符主要有以下几个：

```bash
^ $ . [ ] *
```

而拓展正则表达式在上述元字符的基础上增加了：

```bash
( ) { } ? + | 
```

等字符，接下来我们将逐一展开各个元字符的作用。


### 基础正则表达式 BRE

正则表达式的元字符会起到以下的三个作用，从而定义某种特殊的字符模式：

- 匹配字符（`.`  `[anychar]`, `\`）
- 匹配次数（`*`）
- 位置锚定（`^`, `$`）

粗略的可以划分为以上的三类，而详细的作用则如同下表所示。

| 字符     | 作用                                                           |
| -------- | -------------------------------------------------------------- |
| `^`      | 写在 Pattern 的开头，如 `^header`，匹配以 header 开头的行      |
| ` $`      | 写在 Pattern 的结尾，如 `tail$ `，将匹配以 tail 结尾的行        |
| `^$`     | 组合符，表示空行                                               |
| `\`      | 转义符，让特殊的这些元字符不做元字符，而作为普通字符来进行匹配 |
| `.`      | 匹配任意一个字符（非空行）一次                                 |
| `*`      | 匹配前一个字符（连续出现）0 次到无穷次                         |
| `.*`     | 组合符，将匹配一切                                             |
| `^.*`    | 组合符，匹配以任意字符串开头的内容                             |
| `.*$`    | 组合符，匹配以任意字符串结尾的内容                             |
| `[abc]`  | 匹配 `[]` 集合中的任意字符，a 或 b 或 c，可以写成 `[a-c]`      |
| `[^abc]` | 上述匹配的反向，匹配除了 `[]` 集合中的任意字符，^表示取反      |

此外还有如下的两种正则：

-   `\<` 表示词首。如：`\<abc` 表示以 abc 为首的词。
-   `\>` 表示词尾。如：`abc\>` 表示以 abc 结尾的词。

### 拓展正则表达式 ERE

拓展表达式拓展了上述三个字符模式的元组，拓展字符支持的如下：

- 匹配字符：`|`，`()`
- 匹配次数：`+`，`？`，`{n, m}`
- 位置锚定：

| 字符    | 作用                                                                      |
| ------- | ------------------------------------------------------------------------- |
| `+`     | 匹配**前一个字符**（连续出现）1 次到无穷次                                |
| `[ab]+` | 组合符，匹配 `[]` 中的 a/b 一次到 N 次                                    |
| `?`     | 匹配**前一个字符**（连续出现）0 次到 1 次                                 |
| `\|`   | 或者，表示同时过滤多个字符串                                              |
| `()`    | 分组过滤，括号起来的内容表示一个整体                                      |
| `{n,m}` | 匹配**前一个字符** n 到 m 次，`n,` 表示>=n, `,m` 表示<=m, `n` 表示正好为n |

> 其中表示或者的是|，由于表格的原因显示有问题。

### 特殊符号表

下面这些特殊匹配的字符，需要用的时候查表即可。

| 符号                      | 匹配字符                                  |
| ------------------------- | ----------------------------------------- |
| `[:alnum:]`               | 同 ` [0-9a-zA-Z] ` 匹配数字和字母         |
| `[:alpha:]`               | 同 `[a-zA-Z]` 匹配大小写字母              |
| `[:upper:]` / `[:lower:]` | 同 `[A-Z]` / `[a-z]` 匹配大/小写字母      |
| `[:blank:]`               | 空白字符，空格和制表符                    |
| `[:space:]`               | 水平和垂直的空白字符，比 blank 的范围更广 |
| `[:cntrl:]`               | 不可打印的控制字符（退格，删除，警铃）    |
| `[:digit:]`               | 十进制数字或 `[0-9]`                      |
| `[:xdigit:]`              | 十六进制数字                              |
| `[:graph:]`               | 可打印的非空白字符                        |
| `[:print:]`               | 可打印字符                                |
| `[:punct:]`               | 标点符号                                          |

需要注意的是，使用 zsh 的时候，这些特殊字符可能会出现 ` zsh no matches found ` 的错误，这是因为 zsh 把这些特殊符号当成了命令行的参数，而不是 grep 的参数，因此导致失效。

为此可以在 zshrc 中添加以下命令，使其兼容 bash 的模式。

```rc
setopt no_nomatch
```

参考资料：[ zsh下报错“zsh: no matches found:” CSDN](https://blog.csdn.net/duke_ding2/article/details/123909360)


## 用法补充

### 分组机制详解

待补充

## 正则表达式与通配符

参考资料：[通配符 | Linux基础概要 (gitbooks.io)](https://abcfy2.gitbooks.io/linux_basic/content/first_sense_for_linux/command_learning/wildcard.html)

通配符用于通配文件名，正则表达式用于匹配文本内容；且通配符通常只能用于 shell，被 shell 自解释，正则表达式则需要正则引擎进行处理，用在支持正则表达式的引擎或者命令中。

在 Bash 中，通配符只有三个符号：`*`，`?`, `[]`

| 通配符 | 作用                                                                             |
| ------ | -------------------------------------------------------------------------------- |
| `？`   | 匹配任意的单个字符                                                               |
| `*`    | 匹配任意的多个字符                                                               |
| `**`   | 匹配任意级别目录(bash 4.0以上版本支持，**shopt -s globstar**)                    |
| `[]`   | 匹配一个单字符范围,如[a-z],[0-9],特殊用法可以参考上面的特殊符号表，^亦可表示反向 |

> 	注意 \\ 或者 `“ ”` `‘’` 都会使得通配符失效。

一些具体的用法：

```shell

ls *.txt               # 匹配全部后缀为.txt的文件
ls file?.log           # 匹配file1.log, file2.log, ...
ls [a-z]*.log          # 匹配a-z开头的.log文件
ls [^a-z]*.log         # 上面的反向匹配
ls /etc/**/*.conf      # etc中任意多级目录下的conf文件。

```

## Fi

正则部分的基本内容就是上述的这些，后续如果有遇到一些特殊的用法，以及进阶的用法会在上述补充；基础的正则规则了解后，介绍 grep 的使用，并基于 grep 的使用对正则表达式进行练习。